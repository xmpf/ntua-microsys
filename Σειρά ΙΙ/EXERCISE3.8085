

; X[3] = A[3] & B[3]
; X[2] = A[2] & B[2]
; X[1] = A[1] | B[1]
; X[0] = X[1] ^ (A[0] | B[0])


START:  LDA 2000H	; READ INPUT
					; ACCUMULATOR: A[3] B[3] A[2] B[2] A[1] B[1] A[0] B[0]
		MOV B, A 	; B = A[3] B[3] A[2] B[2] A[1] B[1] A[0] B[0]
		RRC			; ROTATE RIGHT CIRCULAR
					; ACCUMULATOR = B[0] A[3] B[3] A[2] B[2] A[1] B[1] A[0]
		ANA B		; A = A (AND) B
					;	= (A[3]&B[0]) (B[3]&A[3]) (A[2]&B[3]) (B[2]&A[2]) (A[1]&B[1]) (B[1]&A[1]) (A[0]&B[1]) (B[0]&A[0])

		ANI 55H 	; MASK OFF UNINTERESTED BITS
					; A = * (B[3]&A[3]) * (B[2]&A[2]) * (B[1]&A[1]) * (B[0]&A[0])
					;     0		1		0		1	  0		1		0	1 = 0x55

		MOV D, A 	; D = 0 (B[3]&A[3]) 0 (B[2]&A[2]) 0 (B[1]&A[1]) 0 (B[0]&A[0])

		ANI 40H		; MASK OFF ALL BUT (B[3]&A[3])
					; A = 0 (B[3]&A[3]) 0 0 0 0 0 0
		RRC
		RRC
		RRC			; A = 0 0 0 0 X[3] 0 0 0
		MVI	C, 00H  ; C = 0
		ADD C 		; C += ACCUMULATOR => C = X[3] 0 0 0
		MOV A, D 	; A = D = 0 (B[3]&A[3]) 0 (B[2]&A[2]) 0 (B[1]&A[1]) 0 (B[0]&A[0])
		ANI 10H		; MASK OFF ALL BUT (B[2]&A[2])
					; A = 0 0 0 X[2] 0 0 0 0
		RRC
		RRC
		ADD C 		; C += ACCUMULATOR => C = X[3] X[2] 0 0
		
		MOV A, B 	; A = B = A[3] B[3] A[2] B[2] A[1] B[1] A[0] B[0]
		RRC			; ROTATE RIGHT CIRCULAR
					; A = B[0] A[3] B[3] A[2] B[2] A[1] B[1] A[0]
					; B = A[3] B[3] A[2] B[2] A[1] B[1] A[0] B[0]

		ORA B 		; A = (B[0] | A[3]) (A[3] | B[3]) (B[3] | A[2]) (A[2] | B[2]) (B[2] | A[1]) (A[1] | B[1]) (B[1] | A[0]) (A[0] | B[0])
		MOV B, A 	;
					;			 0 			  0 			0 			  0 			0 			  1 			0 			  0
		ANI 04H		; MASK OFF ALL BUT (B[1] | A[1])
					; A = 0 0 0 0 0 X[1] 0 0
		RRC			; ROTATE RIGHT CIRCULAR -- MAKE X[1] LSB
					; A = 0 0 0 0 0 0 X[1] 0
		RRC			; ROTATE ACCUM RIGHT CIRCULAR
		MOV D, A 	; D = 0 0 0 0 0 0 0 X[1]
		RLC			; ROTATE ACCUM LEFT CIRCULAR -- UNDO LAST RRC
		ADD C 		; C += A ==> C = X[3] X[2] X[1] 0

		MOV A, B 	; A = (B[0] | A[3]) (A[3] | B[3]) (B[3] | A[2]) (A[2] | B[2]) (B[2] | A[1]) (A[1] | B[1]) (B[1] | A[0]) (A[0] | B[0])
		ANI 01H		; A = 0 0 0 0 0 0 0 Y[0]
					; Y[0] = (A[0] | B[0])
		XRA D		; A = Y[0] ^ X[1] = X[0]
		ADD C 		; C += A => C = X[3] X[2] X[1] X[0]
		CMA			; COMPLEMENT ACCUM -- A = ~A
		STA 3000H	; OUTPUT
		JMP START	; UNCONDITIONAL JUMP -- START OVER